# -*- coding: utf-8 -*-
"""functions&files&exceptions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17TiwZU726YCAkhIAbq0eICg1P-aVPJhW

## Functions
A function is a block of organized, reusable code that is used to perform a single, related action.
```shell
def functionname( parameters ):
    "function_docstring"
    function_suite
    return [expression]
```

## how computer calulate sin(x)
<img src="assets/images/sin_maclaurin_series.jpg">
<img src="assets/images/fact.png">
"""

def fact(x): # in this case x is the input
    result = 1
    for i in range(x, 1, -1):
        result = result* i
    return result # output

print(fact(3)) # function calling
print(fact(4)) # function calling

def sin(angle): # in this case angle is the input
    angle_rad = angle*3.14/180
    result = 0
    counter = 0
    for i in range(0,5):
        # 0 1 2i+1
        # 1 3 2i+1
        # 2 5 2i+1
        sin_exp_val = 2*i + 1
        if i%2 == 0:
            result += angle_rad**sin_exp_val/fact(sin_exp_val)
        else:
            result -= angle_rad**sin_exp_val/fact(sin_exp_val)
    return round(result, 2) # output

sin(90)

def circle_area(radius):
    """returns the area of a circle with the given radius""" # docstring
    temp = 3.14 * radius**2 # function body
    return temp

area = circle_area(3.15)
print(f"the circle area is {area} m2")

def draw_square():
    print( '*' * 15)
    print("*{}*".format(' '*13))
    print("*{}*".format(' '*13))
    print( '*' * 15)


draw_square()

def draw_tic_tac_toe_board(board):
    print("*"*13)
    for row in board:
        print(f"* {row[0]} * {row[1]} * {row[2]} *")
    print("*"*13)

board = [
    ['_' , '_' , 'O'],
    ['_' , 'X' , '_'],
    ['_' , '_' , '_']
]
draw_tic_tac_toe_board(board)
row_pos = int(input("pls enter row pos:"))
col_pos = int(input("pls enter col pos:"))
select = input("select o/x")
board[row_pos][col_pos] = select.upper()
draw_tic_tac_toe_board(board)

def num_buses(n):
    """ (int) -> int

    Precondition: n > 0

    Return the minimum number of buses required to transport n people.
    Each bus can hold 50 people.

    >>> num_buses(75)
    2
    >>> num_buses(0)
    0
    >>> num_buses(25)
    1
    >>> num_buses(50)
    1
    """

print( num_buses(75))

help(num_buses)

def stock_price_summary(price_changes):
    """ (list of number) -> (number, number) tuple

    price_changes contains a list of stock price changes. Return a 2-item
    tuple where the first item is the sum of the gains in price_changes and
    the second is the sum of the losses in price_changes.

    >>> stock_price_summary([0.01, 0.03, -0.02, -0.14, 0, 0, 0.10, -0.01])
    (0.14, -0.17)
    """

prices = [0.01, 0.03, -0.02, -0.14, 0, 0, 0.10, -0.01]

help(stock_price_summary)

import doctest
doctest.testmod()

def reset():
    time_left = 0

def print_time():
    print(time_left)

time_left = 70
reset()
print_time()

"""<span style="color:red;"> Note:If a function wants to change the value of a shared variable, we need to tell the function that variable is a global variable. We use a global statement in the function to do this. On the other
hand, if we just want to use the value of the global variable, we do not need a global statement.</span>
"""

def reset():
    global time_left , x
    time_left = 0

def print_time():
    print(time_left)

x = 0
time_left = 70
reset()
print_time()

"""## Don't forget global variables are evils try to avoid them if you can.

## > pass by value and pass by reference
"""

def pass_by_value(x): # x is any immutable value
    x = x+2

def pass_by_reference(y):# y is any mutable value
    y.append(20)

val1 = 3
pass_by_value(val1)
print(f"the value of val1 is {val1}")
l = [1 , 2, -90]
pass_by_reference(l)
print(f"the value of l is {l}")

"""## > Default arguments and keyword arguments"""

help(print)

print(1 , "mohamed" , 20 , -9 , sep="********",end="\t" )
print("hello world")

print(1 , "mohamed" , 20 , -9 , sep=' ')

print(1 , "mohamed" , 20 , -9 , sep=' (space replacement) ')

l = [1 , "mohamed" , 20 , -9]
for ele in l:
    print(ele)
print("*"*20)
for ele in l:
    print(ele, end=" (\\n replacement) ")

for i in range(5):
    print("hello world" , end="*****")

def any_fun(a,b=-13):
    print(f"the value of a {a} and the value of b {b}")

any_fun(2)
any_fun(-5,90)

def any_fun(a, b=3, c=8):
    print(f"the value of a {a} and the value of b {b} and the value of c {c}")

any_fun(2)
print("*"*20)
any_fun(2, 5)

# what if you want to put the 5 in c instead of b
any_fun(2, c=5)

# if you use the argumant names you can pass the prams in any arrangment
any_fun(c=5, a=-8 , b=-90)

print(1 , 2 , 3 , 4 , 5 , 20 , 90)



"""## > args, kwargs
You may want to write a function for which you don’t know how many arguments will be passed
to it. An example is the print function where you can enter however many things you want to
print, each separated by commas.
Python allows us to declare a special argument that collects several other arguments into a tuple.
"""

def fun(*args, sep=" " , end="\n"):
    for ele in args:
        print(ele)


fun(1,2,3,4,5)

def sum_all(*args):
    summ = 0
    for ele in args:
        summ += ele
    return summ

sum_all(1,2,3,4,5)

def product(*args):
    print(type(args))
    prod = 1
    for i in args:
        prod*=i
    return prod
print(product(2,3,4 , -90 , 10 , 15 ) )
print(product(2,3))

"""There is a similar notation, ** , for collecting an arbitrary number of keyword arguments into a
dictionary.
"""

def f(**keyargs):
    print(type(keyargs))
    for k in keyargs:
        print(k, '**2 :' , keyargs[k]**2, sep='')
f(x=3, y=4, z=5)

def f(a,b=7,*args,c = 5,**kwargs):
    print(f"the value of a {a}")
    print(f"the value of b {b}")
    print(f"the value of args {args}")
    print(f"the value of c {c}")
    print(f"the value of kwargs {kwargs}")

f(5,2,7,8,c=7,x=20,y=10)

f(5,2,c=7,x=20,y=10)

f(5)

"""## > don't forget that the function name hold it's address"""

def display_welcome(name:str)-> None:
    print(f"welcome {name}")
display_welcome("mohamed")

x = display_welcome
x("mohamed")

"""## > lambda
anonymous function means that a function is without a name. As we already know that def keyword is used to define the normal functions and the lambda keyword is used to create anonymous functions. It has the following syntax:
```shell
lambda arguments: expression
```
<ul>
    <li>
This function can have any number of arguments but only one expression, which is evaluated and returned.
        </li><li>
One is free to use lambda functions wherever function objects are required.
    </li><li>
You need to keep in your knowledge that lambda functions are syntactically restricted to a single expression.</li>
</ul>
"""

def cube(y):
    return y*y*y

g = lambda y: y**3
print(g(5))

print(cube(5))



print((lambda x: x**3)(5))

def add_two_numbers(a,b):
    return a+b
x = lambda a,b: a+b
print(x(2,5))

add_two_numbers(2,5)
print((lambda a,b: a+b)(2,5))

(lambda x: x + 1)(2)

full_name = lambda first,last: f'Full name: {first.title()} {last.title()}'
print(full_name('mohamed', 'yehia'))

"""## map
The built-in function map() takes a function as a first argument and applies it to each of the elements of its second argument, an iterable. Examples of iterables are strings, lists, and tuples.
```shell
    map(function, iterables)
```

list(map(lambda x: x.capitalize(), ['cat', 'dog', 'cow']))
"""

def myfunc(a):
    return a.capitalize()

x = map(myfunc, ['apple', 'banana', 'cherry'])
print(list(x))

"""## filter
The filter() function returns an iterator were the items are filtered through a function to test if the item is accepted or not.
```shell
    filter(function, iterable)
```

"""

print(list(map(lambda x: x%2 == 0, [0 ,1,2,3,4,5,6])))

print([ x for x in range(7) if x%2 == 0])

"""## How to import lib"""

import math  # using lib name
print(math.sin(30)) # to call a function from the file use libname.fun_name

from math import sin, cos  # use functions name
print(sin(30))

from math import *  # this will import all functions in the lib
print(exp(1))

import math as any_name # this like the first method but it become very handy when the lib name is too long
print(any_name.sin(30))

"""# Files
File Paths
When you access a file on an operating system, a file path is required. The file path is a string that represents the location of a file. It’s broken up into three major parts
<ul>
    <li>
Folder Path: the file folder location on the file system where subsequent folders are separated by a forward slash / (Unix) or backslash \ (Windows)</li><li>
File Name: the actual name of the file</li><li>
Extension: the end of the file path pre-pended with a period (.) used to indicate the file type</li>
    </ul>
<img src="assets/images/file_paths.jpg">

## > Opening and Closing a File in Python
To open a file, you need to use the built-in open function. The open function returns a file object that contains methods and attributes to perform various operations on the file.

Syntax
```shell
file_object  = open("filename", "mode")
```
<ul>
   <li>filename: gives name of the file that the file object has opened</li>
   <li>mode: attribute of a file object tells you which mode a file was opened in.</li>
</ul>
<img src="assets/images/file_open_modes.png">
r+ : Opens a file for reading and writing, placing the pointer at the beginning of the file
"""

file = open(r"/home/mohamed/Desktop/foo1.txt" , "w") # using abs path
file.write("hello world1")
file.close()

file = open(r"foo.txt" , "w")
file.write("hello world")
file.close()

file_h_1 = open("file.txt" , "w") # this will create file called file.txt in the same directory if the file not existed
file_h_2 = open("/home/mohamed/Desktop/file.txt" , "w") # this will create file called file.txt using abs path
file_h_1.write("hello world")
file_h_2.write("hello world")
file_h_1.close() # don't forget to close the file
file_h_2.close()

# another way to avoid forgotten of the close
with open("file.txt" , "w") as file:
    file.write("hello world")

with open("file.txt" , "a") as file:
    file.write("\nthis another line")

with open("ljkenfoeoh.txt" , "x") as file:
    for i in range(1000):
        file.write("\nthis another line")

"""#### Reading
<img src="assets/images/read_mode.png">
"""

with open("test_file.foo" , "w") as file:
    for i in range(10):
        file.write(f"hello world_{i}\n")

with open("test_file.txt" , "r") as file_h:
    print(file_h.readlines())

with open("test_file.txt" , "r") as file:
    print(file.readline())

with open("test_file.foo" , "r") as file:
    print(file.read())

# itreate over file line by line
with open("test_file.txt" , "r") as file_h:
    for line in file_h:
        print(line.rstrip("\n") )

"""## Lets Fun !"""

# Brute Force attack
from itertools import product
chars = '0123456789' # chars to look for
for length in range(1, 4): # only do lengths of 1 + 2
    to_attempt = product(chars, repeat=length)
    for attempt in to_attempt:
        print(''.join(attempt), end=",")

x = 5/0
print("hello world")

try:
    x = 5/1
    print(x)
except:
    pass
print("end of the code ........")

try:
    x = 5/2
    print(x)
except:
    pass
print("end of the code ........")

from zipfile import ZipFile
with ZipFile(r'extra_files/test1.zip') as zf:
    zf.extractall(pwd="45445464".encode())

"""<img src="assets/images/encode_decode.png">"""

# 0x33 is the ascii code for digit 3
# 0x30 is the ascii code for digit 0
# 0x65 is the ascii code for char e
b"\x33\x30\x65".decode()

'30e'.encode()

from zipfile import ZipFile
with ZipFile('extra_files/test1.zip') as zf:
    zf.extractall(pwd="hey1534".encode())

from zipfile import ZipFile
with open(r"extra_files/10-million-password-list-top-1000000.txt" , "r") as file_h:
    for line in file_h:
        word = line.strip("\n")
        with ZipFile(r'extra_files/test1.zip') as zf:
            try:
                zf.extractall(pwd=bytes(word , "utf-8"))
                print("opended....")
                print(f"the password is {word}")
                break
            except:
                pass

"""# typesof errors
<img src="assets/images/error_types.jpg">
<br>
Anomalies that occur at runtime are known as exceptions. Exceptions are of two types: synchronous exceptions and asynchronous exceptions. Synchronous exceptions are caused due to mistakes in the logic of the program and can be controlled. Asynchronous exceptions are caused due to hardware failure or operating system level failures and cannot be controlled.
<br>
Examples of synchronous exceptions are: divide by zero, array index out of bounds, etc.) .
<br>
Examples of asynchronous exceptions are: out of memory error, memory overflow, memory underflow, disk failure, etc.
"""

import requests
import json
api_key = "204c762825b47ea8dd6859fb9e5b344b"
base_url = "http://api.openweathermap.org/data/2.5/weather?"
complete_url = base_url + "appid=" + api_key + "&q=cairo"
try:
    response = requests.get(complete_url)
    received_dict = response.json()
    print(received_dict)
except requests.ConnectionError:
    print("no internet connection")

# if you are excepected the exceptions that might happens
try:
    numerator = int(input())
    denominator = int(input())
    quotient = numerator / denominator
    print("Quotient:", quotient)
except Exception as e:
    print(e)

try:
    numerator = int(input())
    denominator = int(input())
    quotient = numeradtor / denominator
    print("Quotient:", quotient)
except (NameError, ValueError):
    print("error ................")

"""<img src="assets/images/exception_body.png">"""

file_name = "test_file.txt"
try:
    f = open(file_name, 'r')
except IOError:
    print('cannot open', file_name)
else:
    print (file_name, 'has', len(f.readlines()), 'lines')
    f.close()

"""<img src="assets/images/exceptions_type.png">"""

int("12a")

